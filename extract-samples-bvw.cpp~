#include "extract-samples-bvw.h"

//1.featch the train sample  file path .
//2.start extracting the feautres
//3.wrtie them on disk
//NOTE: now i extract the from the test images not the training ones .
void extract_training_samples(Ptr<FeatureDetector>& detector, BOWImgDescriptorExtractor& bowide, map<string,Mat>& classes_training_data ) {

	int total_samples = 0;
	fstream fs ;
	vector<string> train_imgfilenames;
    fs.open("test.txt") ;
    if ( !fs.is_open() ){
        cerr << "Cannot open test.txt file " << endl ;
        return ;
    }
    string line ;
    while ( getline (fs,line) )
    {
        train_imgfilenames.push_back(line);

    }
    cout << "Whole number of training data = " << train_imgfilenames.size() << endl ;
	// multi threads for extraction the respone_histograms of train img.
	#pragma omp parallel for schedule(dynamic,3) num_threads(4)
	for(size_t i=0;i<train_imgfilenames.size();i++) {
		//printf("Hello from thread %d, nthreads %d\n", omp_get_thread_num(), omp_get_num_threads());

		vector<KeyPoint> keypoints;
		Mat response_hist;
		Mat img;
		string filepath;
        string tmp;
		string class_;
		//extract the filepath and class label from train.txt
		stringstream ss(train_imgfilenames[i] );
		ss >> tmp;
		filepath = tmp ;
		filepath += " ";
		ss >>tmp ;
		filepath += tmp ;
        ss >> class_ ;
        class_ = "class_" + class_ ;
		if(class_.size() == 0) continue;
        //processing on train imgs
		img = imread(filepath);
		//if ( !img.data ){ return ;}
		detector->detect(img,keypoints);
		bowide.compute(img, keypoints, response_hist);

		cout << ".";
        cout.flush();

		#pragma omp critical
		{
			if(classes_training_data.count(class_) == 0) { //not yet created...
				classes_training_data[class_].create(0,response_hist.cols,response_hist.type());
				//classes_names.push_back(class_);
			}
			classes_training_data[class_].push_back(response_hist);
			total_samples++;
		}


		//		waitKey(0);
	}
	cout << endl;
    cout << "Total_samples = " << total_samples << endl;
	cout << "save to file.."<<endl;
	{
        string temp = "test_samples";
        stringstream ss;
        ss << "test_examples_" <<classes_training_data["class_1"].cols << ".yaml" ;
        string outputfile = ss.str() ;
        cout << "outputfile : " << outputfile << endl ;
		FileStorage fs("test_samples/"+outputfile,FileStorage::WRITE);
		//save samples for each class on disk
		for (map<string,Mat>::iterator it = classes_training_data.begin(); it != classes_training_data.end(); ++it) {
			cout << "save  " << (*it).first << endl;
			fs << (*it).first << (*it).second;
		}
	}
}



int extract_samples_bvw_main(int argc , char** argv ){

const string train_data_directory = "dictionary/" ;

	if (argc < 2 ) {
		cerr  << "USAGE: ./extract-samples-bvw [vocabulary_file.yml] "<<endl;
		return -1;
	}

	cout << "-------- train BOVW SVMs -----------" << endl;
	cout << "read vocabulary form file"<<endl;
	Mat vocabulary;
	FileStorage fs(train_data_directory+argv[1], FileStorage::READ);
    if (!fs.isOpened() ){

        cout << " cannot open" << argv[1] << endl ;
        return -1 ;
    }
	fs["vocabulary"] >> vocabulary;
	fs.release();

	Ptr<FeatureDetector> detector = FeatureDetector::create("SIFT");
    Ptr<DescriptorExtractor> extractor = DescriptorExtractor::create("SIFT");
	Ptr<DescriptorMatcher > matcher(new  BruteForceMatcher<L2<float> >());
	BOWImgDescriptorExtractor bowide(extractor,matcher);
	bowide.setVocabulary(vocabulary);

	cout << "BOW has Vocabulary Size = " << vocabulary.cols << endl ;
	cout << "BOW it's Descriptor Types : " << bowide.descriptorType() << endl ;

	//setup training data for classifiers
	map<string,Mat> classes_training_data;
    classes_training_data.clear();

	cout << "extract_testing_samples..." << endl;
	extract_training_samples(detector, bowide, classes_training_data );

	cout << "Number of Classes has been extracted " << classes_training_data.size() << " classes." <<endl;
	for (map<string,Mat>::iterator it = classes_training_data.begin(); it != classes_training_data.end(); ++it) {
		cout  << (*it).first << " has " << (*it).second.rows << " samples(examples) "<<endl;
	}

	//cout << "training  SVMs" << endl ;
//	string postfix = argv[2];
//	trainSVM(classes_training_data, directory_name, bowide.descriptorSize(), bowide.descriptorType());

	return 0;

}

